Hello - from c:\Users\manas\.vscode\extensions\jaredly.reason-vscode-1.7.8\bin.native.exe.hot.exe
Previous log location: C:\Users\manas\AppData\Local\Temp\lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///d%3A/Code/TC/exercC/exerc.ml","languageId":"ocaml","version":1,"text":"type regexp =\r\n  | V  \r\n  | E\r\n  | C of char\r\n  | U of regexp * regexp \r\n  | P of regexp * regexp \r\n  | S of regexp\r\n \r\n module Parser_regexp = struct\r\n \r\n   \r\n module MenhirBasics = struct\r\n   \r\n   exception Error\r\n   \r\n   type token = \r\n     | RPAREN\r\n     | LPAREN\r\n     | EPS\r\n     | EOF\r\n     | EMP\r\n     | CONC\r\n     | CHAR of (\r\n        (char)\r\n   )\r\n     | AST\r\n     | ALT\r\n   \r\n end\r\n \r\n include MenhirBasics\r\n \r\n let _eRR =\r\n   MenhirBasics.Error\r\n \r\n type _menhir_env = {\r\n   _menhir_lexer: Lexing.lexbuf -> token;\r\n   _menhir_lexbuf: Lexing.lexbuf;\r\n   _menhir_token: token;\r\n   mutable _menhir_error: bool\r\n }\r\n \r\n and _menhir_state = \r\n   | MenhirState12\r\n   | MenhirState7\r\n   | MenhirState6\r\n   | MenhirState1\r\n   | MenhirState0\r\n \r\n \r\n let rec _menhir_goto_expr : _menhir_env -> 'ttv_tail -> _menhir_state -> 'tv_expr -> 'ttv_return =\r\n   fun _menhir_env _menhir_stack _menhir_s _v ->\r\n     let _menhir_stack = (_menhir_stack, _menhir_s, _v) in\r\n     match _menhir_s with\r\n     | MenhirState6 ->\r\n         let (_menhir_env : _menhir_env) = _menhir_env in\r\n         let (_menhir_stack : (('freshtv47 * _menhir_state * 'tv_term)) * _menhir_state * 'tv_expr) = Obj.magic _menhir_stack in\r\n         ((let (_menhir_env : _menhir_env) = _menhir_env in\r\n         let (_menhir_stack : (('freshtv45 * _menhir_state * 'tv_term)) * _menhir_state * 'tv_expr) = Obj.magic _menhir_stack in\r\n         ((let ((_menhir_stack, _menhir_s, (e1 : 'tv_term)), _, (e2 : 'tv_expr)) = _menhir_stack in\r\n         let _2 = () in\r\n         let _v : 'tv_expr = \r\n                                 ( P (e1, e2) )\r\n          in\r\n         _menhir_goto_expr _menhir_env _menhir_stack _menhir_s _v) : 'freshtv46)) : 'freshtv48)\r\n     | MenhirState12 ->\r\n         let (_menhir_env : _menhir_env) = _menhir_env in\r\n         let (_menhir_stack : (('freshtv51 * _menhir_state * 'tv_term)) * _menhir_state * 'tv_expr) = Obj.magic _menhir_stack in\r\n         ((let (_menhir_env : _menhir_env) = _menhir_env in\r\n         let (_menhir_stack : (('freshtv49 * _menhir_state * 'tv_term)) * _menhir_state * 'tv_expr) = Obj.magic _menhir_stack in\r\n         ((let ((_menhir_stack, _menhir_s, (e1 : 'tv_term)), _, (e2 : 'tv_expr)) = _menhir_stack in\r\n         let _2 = () in\r\n         let _v : 'tv_expr = \r\n                                 ( U (e1, e2) )\r\n          in\r\n         _menhir_goto_expr _menhir_env _menhir_stack _menhir_s _v) : 'freshtv50)) : 'freshtv52)\r\n     | MenhirState1 ->\r\n         let (_menhir_env : _menhir_env) = _menhir_env in\r\n         let (_menhir_stack : ('freshtv59 * _menhir_state) * _menhir_state * 'tv_expr) = Obj.magic _menhir_stack in\r\n         ((assert (not _menhir_env._menhir_error);\r\n         let _tok = _menhir_env._menhir_token in\r\n         match _tok with\r\n         | RPAREN ->\r\n             let (_menhir_env : _menhir_env) = _menhir_env in\r\n             let (_menhir_stack : ('freshtv55 * _menhir_state) * _menhir_state * 'tv_expr) = Obj.magic _menhir_stack in\r\n             ((let _menhir_env = _menhir_discard _menhir_env in\r\n             let (_menhir_env : _menhir_env) = _menhir_env in\r\n             let (_menhir_stack : ('freshtv53 * _menhir_state) * _menhir_state * 'tv_expr) = Obj.magic _menhir_stack in\r\n             ((let ((_menhir_stack, _menhir_s), _, (e : 'tv_expr)) = _menhir_stack in\r\n             let _3 = () in\r\n             let _1 = () in\r\n             let _v : 'tv_atom = \r\n                                 ( e )\r\n              in\r\n             _menhir_goto_atom _menhir_env _menhir_stack _menhir_s _v) : 'freshtv54)) : 'freshtv56)\r\n         | _ ->\r\n             assert (not _menhir_env._menhir_error);\r\n             _menhir_env._menhir_error <- true;\r\n             let (_menhir_env : _menhir_env) = _menhir_env in\r\n             let (_menhir_stack : ('freshtv57 * _menhir_state) * _menhir_state * 'tv_expr) = Obj.magic _menhir_stack in\r\n             ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in\r\n             _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv58)) : 'freshtv60)\r\n     | MenhirState0 ->\r\n         let (_menhir_env : _menhir_env) = _menhir_env in\r\n         let (_menhir_stack : 'freshtv73 * _menhir_state * 'tv_expr) = Obj.magic _menhir_stack in\r\n         ((assert (not _menhir_env._menhir_error);\r\n         let _tok = _menhir_env._menhir_token in\r\n         match _tok with\r\n         | EOF ->\r\n             let (_menhir_env : _menhir_env) = _menhir_env in\r\n             let (_menhir_stack : 'freshtv69 * _menhir_state * 'tv_expr) = Obj.magic _menhir_stack in\r\n             ((let (_menhir_env : _menhir_env) = _menhir_env in\r\n             let (_menhir_stack : 'freshtv67 * _menhir_state * 'tv_expr) = Obj.magic _menhir_stack in\r\n             ((let (_menhir_stack, _menhir_s, (le : 'tv_expr)) = _menhir_stack in\r\n             let _2 = () in\r\n             let _v : (\r\n        (regexp)\r\n             ) = \r\n                                 ( le )\r\n              in\r\n             let (_menhir_env : _menhir_env) = _menhir_env in\r\n             let (_menhir_stack : 'freshtv65) = _menhir_stack in\r\n             let (_menhir_s : _menhir_state) = _menhir_s in\r\n             let (_v : (\r\n        (regexp)\r\n             )) = _v in\r\n             ((let (_menhir_env : _menhir_env) = _menhir_env in\r\n             let (_menhir_stack : 'freshtv63) = Obj.magic _menhir_stack in\r\n             let (_menhir_s : _menhir_state) = _menhir_s in\r\n             let (_v : (\r\n        (regexp)\r\n             )) = _v in\r\n             ((let (_menhir_env : _menhir_env) = _menhir_env in\r\n             let (_menhir_stack : 'freshtv61) = Obj.magic _menhir_stack in\r\n             let (_menhir_s : _menhir_state) = _menhir_s in\r\n             let ((_1 : (\r\n        (regexp)\r\n             )) : (\r\n        (regexp)\r\n             )) = _v in\r\n             (Obj.magic _1 : 'freshtv62)) : 'freshtv64)) : 'freshtv66)) : 'freshtv68)) : 'freshtv70)\r\n         | _ ->\r\n             assert (not _menhir_env._menhir_error);\r\n             _menhir_env._menhir_error <- true;\r\n             let (_menhir_env : _menhir_env) = _menhir_env in\r\n             let (_menhir_stack : 'freshtv71 * _menhir_state * 'tv_expr) = Obj.magic _menhir_stack in\r\n             ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in\r\n             _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv72)) : 'freshtv74)\r\n     | _ ->\r\n         let (() : unit) = () in\r\n         ((Printf.fprintf stderr \"Internal failure -- please contact the parser generator's developers.\\n%!\";\r\n         assert false) : 'freshtv75)\r\n \r\n and _menhir_goto_term : _menhir_env -> 'ttv_tail -> _menhir_state -> 'tv_term -> 'ttv_return =\r\n   fun _menhir_env _menhir_stack _menhir_s _v ->\r\n     let _menhir_stack = (_menhir_stack, _menhir_s, _v) in\r\n     match _menhir_s with\r\n     | MenhirState0 | MenhirState12 | MenhirState6 | MenhirState1 ->\r\n         let (_menhir_env : _menhir_env) = _menhir_env in\r\n         let (_menhir_stack : 'freshtv39 * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in\r\n         ((assert (not _menhir_env._menhir_error);\r\n         let _tok = _menhir_env._menhir_token in\r\n         match _tok with\r\n         | ALT ->\r\n             let (_menhir_env : _menhir_env) = _menhir_env in\r\n             let (_menhir_stack : 'freshtv31 * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in\r\n             ((let _menhir_env = _menhir_discard _menhir_env in\r\n             let _tok = _menhir_env._menhir_token in\r\n             match _tok with\r\n             | CHAR _v ->\r\n                 _menhir_run4 _menhir_env (Obj.magic _menhir_stack) MenhirState12 _v\r\n             | EMP ->\r\n                 _menhir_run3 _menhir_env (Obj.magic _menhir_stack) MenhirState12\r\n             | EPS ->\r\n                 _menhir_run2 _menhir_env (Obj.magic _menhir_stack) MenhirState12\r\n             | LPAREN ->\r\n                 _menhir_run1 _menhir_env (Obj.magic _menhir_stack) MenhirState12\r\n             | _ ->\r\n                 assert (not _menhir_env._menhir_error);\r\n                 _menhir_env._menhir_error <- true;\r\n                 _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState12) : 'freshtv32)\r\n         | CONC ->\r\n             let (_menhir_env : _menhir_env) = _menhir_env in\r\n             let (_menhir_stack : 'freshtv33 * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in\r\n             ((let _menhir_env = _menhir_discard _menhir_env in\r\n             let _tok = _menhir_env._menhir_token in\r\n             match _tok with\r\n             | CHAR _v ->\r\n                 _menhir_run4 _menhir_env (Obj.magic _menhir_stack) MenhirState6 _v\r\n             | EMP ->\r\n                 _menhir_run3 _menhir_env (Obj.magic _menhir_stack) MenhirState6\r\n             | EPS ->\r\n                 _menhir_run2 _menhir_env (Obj.magic _menhir_stack) MenhirState6\r\n             | LPAREN ->\r\n                 _menhir_run1 _menhir_env (Obj.magic _menhir_stack) MenhirState6\r\n             | _ ->\r\n                 assert (not _menhir_env._menhir_error);\r\n                 _menhir_env._menhir_error <- true;\r\n                 _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState6) : 'freshtv34)\r\n         | EOF | RPAREN ->\r\n             let (_menhir_env : _menhir_env) = _menhir_env in\r\n             let (_menhir_stack : 'freshtv35 * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in\r\n             ((let (_menhir_stack, _menhir_s, (e : 'tv_term)) = _menhir_stack in\r\n             let _v : 'tv_expr = \r\n                                 ( e )\r\n              in\r\n             _menhir_goto_expr _menhir_env _menhir_stack _menhir_s _v) : 'freshtv36)\r\n         | _ ->\r\n             assert (not _menhir_env._menhir_error);\r\n             _menhir_env._menhir_error <- true;\r\n             let (_menhir_env : _menhir_env) = _menhir_env in\r\n             let (_menhir_stack : 'freshtv37 * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in\r\n             ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in\r\n             _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv38)) : 'freshtv40)\r\n     | MenhirState7 ->\r\n         let (_menhir_env : _menhir_env) = _menhir_env in\r\n         let (_menhir_stack : ('freshtv43 * _menhir_state * 'tv_factor) * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in\r\n         ((let (_menhir_env : _menhir_env) = _menhir_env in\r\n         let (_menhir_stack : ('freshtv41 * _menhir_state * 'tv_factor) * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in\r\n         ((let ((_menhir_stack, _menhir_s, (e1 : 'tv_factor)), _, (e2 : 'tv_term)) = _menhir_stack in\r\n         let _v : 'tv_term = \r\n                                 ( P (e1, e2) )\r\n          in\r\n         _menhir_goto_term _menhir_env _menhir_stack _menhir_s _v) : 'freshtv42)) : 'freshtv44)\r\n \r\n and _menhir_goto_factor : _menhir_env -> 'ttv_tail -> _menhir_state -> 'tv_factor -> 'ttv_return =\r\n   fun _menhir_env _menhir_stack _menhir_s _v ->\r\n     let _menhir_stack = (_menhir_stack, _menhir_s, _v) in\r\n     let (_menhir_env : _menhir_env) = _menhir_env in\r\n     let (_menhir_stack : 'freshtv29 * _menhir_state * 'tv_factor) = Obj.magic _menhir_stack in\r\n     ((assert (not _menhir_env._menhir_error);\r\n     let _tok = _menhir_env._menhir_token in\r\n     match _tok with\r\n     | CHAR _v ->\r\n         _menhir_run4 _menhir_env (Obj.magic _menhir_stack) MenhirState7 _v\r\n     | EMP ->\r\n         _menhir_run3 _menhir_env (Obj.magic _menhir_stack) MenhirState7\r\n     | EPS ->\r\n         _menhir_run2 _menhir_env (Obj.magic _menhir_stack) MenhirState7\r\n     | LPAREN ->\r\n         _menhir_run1 _menhir_env (Obj.magic _menhir_stack) MenhirState7\r\n     | ALT | CONC | EOF | RPAREN ->\r\n         let (_menhir_env : _menhir_env) = _menhir_env in\r\n         let (_menhir_stack : 'freshtv27 * _menhir_state * 'tv_factor) = Obj.magic _menhir_stack in\r\n         ((let (_menhir_stack, _menhir_s, (e : 'tv_factor)) = _menhir_stack in\r\n         let _v : 'tv_term = \r\n                                 ( e )\r\n          in\r\n         _menhir_goto_term _menhir_env _menhir_stack _menhir_s _v) : 'freshtv28)\r\n     | _ ->\r\n         assert (not _menhir_env._menhir_error);\r\n         _menhir_env._menhir_error <- true;\r\n         _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState7) : 'freshtv30)\r\n \r\n and _menhir_goto_atom : _menhir_env -> 'ttv_tail -> _menhir_state -> 'tv_atom -> 'ttv_return =\r\n   fun _menhir_env _menhir_stack _menhir_s _v ->\r\n     let _menhir_stack = (_menhir_stack, _menhir_s, _v) in\r\n     let (_menhir_env : _menhir_env) = _menhir_env in\r\n     let (_menhir_stack : 'freshtv25 * _menhir_state * 'tv_atom) = Obj.magic _menhir_stack in\r\n     ((assert (not _menhir_env._menhir_error);\r\n     let _tok = _menhir_env._menhir_token in\r\n     match _tok with\r\n     | AST ->\r\n         let (_menhir_env : _menhir_env) = _menhir_env in\r\n         let (_menhir_stack : 'freshtv21 * _menhir_state * 'tv_atom) = Obj.magic _menhir_stack in\r\n         ((let _menhir_env = _menhir_discard _menhir_env in\r\n         let (_menhir_env : _menhir_env) = _menhir_env in\r\n         let (_menhir_stack : 'freshtv19 * _menhir_state * 'tv_atom) = Obj.magic _menhir_stack in\r\n         ((let (_menhir_stack, _menhir_s, (e : 'tv_atom)) = _menhir_stack in\r\n         let _2 = () in\r\n         let _v : 'tv_factor = \r\n                                 ( S e )\r\n          in\r\n         _menhir_goto_factor _menhir_env _menhir_stack _menhir_s _v) : 'freshtv20)) : 'freshtv22)\r\n     | ALT | CHAR _ | CONC | EMP | EOF | EPS | LPAREN | RPAREN ->\r\n         let (_menhir_env : _menhir_env) = _menhir_env in\r\n         let (_menhir_stack : 'freshtv23 * _menhir_state * 'tv_atom) = Obj.magic _menhir_stack in\r\n         ((let (_menhir_stack, _menhir_s, (e : 'tv_atom)) = _menhir_stack in\r\n         let _v : 'tv_factor = \r\n                                 ( e )\r\n          in\r\n         _menhir_goto_factor _menhir_env _menhir_stack _menhir_s _v) : 'freshtv24)) : 'freshtv26)\r\n \r\n and _menhir_errorcase : _menhir_env -> 'ttv_tail -> _menhir_state -> 'ttv_return =\r\n   fun _menhir_env _menhir_stack _menhir_s ->\r\n     match _menhir_s with\r\n     | MenhirState12 ->\r\n         let (_menhir_env : _menhir_env) = _menhir_env in\r\n         let (_menhir_stack : ('freshtv9 * _menhir_state * 'tv_term)) = Obj.magic _menhir_stack in\r\n         ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in\r\n         _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv10)\r\n     | MenhirState7 ->\r\n         let (_menhir_env : _menhir_env) = _menhir_env in\r\n         let (_menhir_stack : 'freshtv11 * _menhir_state * 'tv_factor) = Obj.magic _menhir_stack in\r\n         ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in\r\n         _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv12)\r\n     | MenhirState6 ->\r\n         let (_menhir_env : _menhir_env) = _menhir_env in\r\n         let (_menhir_stack : ('freshtv13 * _menhir_state * 'tv_term)) = Obj.magic _menhir_stack in\r\n         ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in\r\n         _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv14)\r\n     | MenhirState1 ->\r\n         let (_menhir_env : _menhir_env) = _menhir_env in\r\n         let (_menhir_stack : 'freshtv15 * _menhir_state) = Obj.magic _menhir_stack in\r\n         ((let (_menhir_stack, _menhir_s) = _menhir_stack in\r\n         _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv16)\r\n     | MenhirState0 ->\r\n         let (_menhir_env : _menhir_env) = _menhir_env in\r\n         let (_menhir_stack : 'freshtv17) = Obj.magic _menhir_stack in\r\n         (raise _eRR : 'freshtv18)\r\n \r\n and _menhir_run1 : _menhir_env -> 'ttv_tail -> _menhir_state -> 'ttv_return =\r\n   fun _menhir_env _menhir_stack _menhir_s ->\r\n     let _menhir_stack = (_menhir_stack, _menhir_s) in\r\n     let _menhir_env = _menhir_discard _menhir_env in\r\n     let _tok = _menhir_env._menhir_token in\r\n     match _tok with\r\n     | CHAR _v ->\r\n         _menhir_run4 _menhir_env (Obj.magic _menhir_stack) MenhirState1 _v\r\n     | EMP ->\r\n         _menhir_run3 _menhir_env (Obj.magic _menhir_stack) MenhirState1\r\n     | EPS ->\r\n         _menhir_run2 _menhir_env (Obj.magic _menhir_stack) MenhirState1\r\n     | LPAREN ->\r\n         _menhir_run1 _menhir_env (Obj.magic _menhir_stack) MenhirState1\r\n     | _ ->\r\n         assert (not _menhir_env._menhir_error);\r\n         _menhir_env._menhir_error <- true;\r\n         _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState1\r\n \r\n and _menhir_run2 : _menhir_env -> 'ttv_tail -> _menhir_state -> 'ttv_return =\r\n   fun _menhir_env _menhir_stack _menhir_s ->\r\n     let _menhir_env = _menhir_discard _menhir_env in\r\n     let (_menhir_env : _menhir_env) = _menhir_env in\r\n     let (_menhir_stack : 'freshtv7) = Obj.magic _menhir_stack in\r\n     let (_menhir_s : _menhir_state) = _menhir_s in\r\n     ((let _1 = () in\r\n     let _v : 'tv_atom = \r\n                                 ( E )\r\n      in\r\n     _menhir_goto_atom _menhir_env _menhir_stack _menhir_s _v) : 'freshtv8)\r\n \r\n and _menhir_run3 : _menhir_env -> 'ttv_tail -> _menhir_state -> 'ttv_return =\r\n   fun _menhir_env _menhir_stack _menhir_s ->\r\n     let _menhir_env = _menhir_discard _menhir_env in\r\n     let (_menhir_env : _menhir_env) = _menhir_env in\r\n     let (_menhir_stack : 'freshtv5) = Obj.magic _menhir_stack in\r\n     let (_menhir_s : _menhir_state) = _menhir_s in\r\n     ((let _1 = () in\r\n     let _v : 'tv_atom = \r\n                                 ( V )\r\n      in\r\n     _menhir_goto_atom _menhir_env _menhir_stack _menhir_s _v) : 'freshtv6)\r\n \r\n and _menhir_run4 : _menhir_env -> 'ttv_tail -> _menhir_state -> (\r\n        (char)\r\n ) -> 'ttv_return =\r\n   fun _menhir_env _menhir_stack _menhir_s _v ->\r\n     let _menhir_env = _menhir_discard _menhir_env in\r\n     let (_menhir_env : _menhir_env) = _menhir_env in\r\n     let (_menhir_stack : 'freshtv3) = Obj.magic _menhir_stack in\r\n     let (_menhir_s : _menhir_state) = _menhir_s in\r\n     let ((c : (\r\n        (char)\r\n     )) : (\r\n        (char)\r\n     )) = _v in\r\n     ((let _v : 'tv_atom = \r\n                                 ( C c )\r\n      in\r\n     _menhir_goto_atom _menhir_env _menhir_stack _menhir_s _v) : 'freshtv4)\r\n \r\n and _menhir_discard : _menhir_env -> _menhir_env =\r\n   fun _menhir_env ->\r\n     let lexer = _menhir_env._menhir_lexer in\r\n     let lexbuf = _menhir_env._menhir_lexbuf in\r\n     let _tok = lexer lexbuf in\r\n     {\r\n       _menhir_lexer = lexer;\r\n       _menhir_lexbuf = lexbuf;\r\n       _menhir_token = _tok;\r\n       _menhir_error = false;\r\n     }\r\n \r\n and regexpr : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (\r\n        (regexp)\r\n ) =\r\n   fun lexer lexbuf ->\r\n     let _menhir_env =\r\n       let (lexer : Lexing.lexbuf -> token) = lexer in\r\n       let (lexbuf : Lexing.lexbuf) = lexbuf in\r\n       ((let _tok = Obj.magic () in\r\n       {\r\n         _menhir_lexer = lexer;\r\n         _menhir_lexbuf = lexbuf;\r\n         _menhir_token = _tok;\r\n         _menhir_error = false;\r\n       }) : _menhir_env)\r\n     in\r\n     Obj.magic (let (_menhir_env : _menhir_env) = _menhir_env in\r\n     let (_menhir_stack : 'freshtv1) = ((), _menhir_env._menhir_lexbuf.Lexing.lex_curr_p) in\r\n     ((let _menhir_env = _menhir_discard _menhir_env in\r\n     let _tok = _menhir_env._menhir_token in\r\n     match _tok with\r\n     | CHAR _v ->\r\n         _menhir_run4 _menhir_env (Obj.magic _menhir_stack) MenhirState0 _v\r\n     | EMP ->\r\n         _menhir_run3 _menhir_env (Obj.magic _menhir_stack) MenhirState0\r\n     | EPS ->\r\n         _menhir_run2 _menhir_env (Obj.magic _menhir_stack) MenhirState0\r\n     | LPAREN ->\r\n         _menhir_run1 _menhir_env (Obj.magic _menhir_stack) MenhirState0\r\n     | _ ->\r\n         assert (not _menhir_env._menhir_error);\r\n         _menhir_env._menhir_error <- true;\r\n         _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState0) : 'freshtv2))\r\n \r\n   \r\n \r\n \r\n \r\n end\r\n \r\n module Lexer_regexp = struct\r\n  \r\n   open Parser_regexp\r\n \r\n   exception Error of string\r\n \r\n \r\n   let __ocaml_lex_tables = {\r\n     Lexing.lex_base =\r\n     \"\\000\\000\\245\\255\\246\\255\\247\\255\\248\\255\\249\\255\\250\\255\\251\\255\\\r\n       \\252\\255\\253\\255\\254\\255\\255\\255\";\r\n     Lexing.lex_backtrk =\r\n     \"\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\255\\255\\255\\255\\255\\255\";\r\n     Lexing.lex_default =\r\n     \"\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\";\r\n     Lexing.lex_trans =\r\n     \"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\011\\000\\011\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\011\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\004\\000\\003\\000\\007\\000\\009\\000\\000\\000\\000\\000\\008\\000\\000\\000\\\r\n       \\006\\000\\005\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\r\n       \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\r\n       \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\r\n       \\010\\000\\010\\000\\010\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\r\n       \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\r\n       \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\r\n       \\010\\000\\010\\000\\010\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\002\\000\";\r\n     Lexing.lex_check =\r\n     \"\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\000\\000\\000\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\000\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\255\\255\\255\\255\\000\\000\\255\\255\\\r\n       \\000\\000\\000\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\r\n       \\000\\000\\000\\000\\000\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\r\n       \\000\\000\";\r\n     Lexing.lex_base_code =\r\n     \"\";\r\n     Lexing.lex_backtrk_code =\r\n     \"\";\r\n     Lexing.lex_default_code =\r\n     \"\";\r\n     Lexing.lex_trans_code =\r\n     \"\";\r\n     Lexing.lex_check_code =\r\n     \"\";\r\n     Lexing.lex_code =\r\n     \"\";\r\n   }\r\n \r\n   let rec tokenize lexbuf =\r\n     __ocaml_lex_tokenize_rec lexbuf 0\r\n   and __ocaml_lex_tokenize_rec lexbuf __ocaml_lex_state =\r\n     match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with\r\n         | 0 ->\r\n                                         ( tokenize lexbuf )\r\n \r\n     | 1 ->\r\n   let\r\n                           s\r\n   = Lexing.sub_lexeme_char lexbuf lexbuf.Lexing.lex_start_pos in\r\n                                         ( CHAR s )\r\n \r\n     | 2 ->\r\n                                         ( ALT )\r\n \r\n     | 3 ->\r\n                                         ( CONC )\r\n \r\n     | 4 ->\r\n                                         ( AST )\r\n \r\n     | 5 ->\r\n                                         ( EMP )\r\n \r\n     | 6 ->\r\n                                         ( EPS )\r\n \r\n     | 7 ->\r\n                                         ( LPAREN )\r\n \r\n     | 8 ->\r\n                                         ( RPAREN )\r\n \r\n     | 9 ->\r\n                                         ( EOF )\r\n \r\n     | 10 ->\r\n         ( raise (Error (Printf.sprintf \"At offset %d: unexpected character.\\n\" (Lexing.lexeme_start lexbuf))) )\r\n \r\n     | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;\r\n         __ocaml_lex_tokenize_rec lexbuf __ocaml_lex_state\r\n \r\n   ;;\r\n end\r\n \r\n (* --------------------------------- fim lexing/parsing code ----------------------------------------------------- *)\r\n \r\n open Parser_regexp\r\n \r\n \r\n (* função principal de leitura de uma expressão regular (a partir de uma string) *)\r\n let regexp st =\r\n   let linebuf = Lexing.from_string st in\r\n   try regexpr Lexer_regexp.tokenize linebuf\r\n   with _ -> failwith \"regexp: input problem\"\r\n \r\n \r\n (* **************************************************************************************************************** *)\r\n (* ********************************************   Começar aqui **************************************************** *)\r\n \r\n (* exemplo de código para ilustrar o uso da função regexp e o tipo regexp *)\r\n let rec string_of_regexp s =\r\n   match s with\r\n   | V       -> \"0\"\r\n   | E       -> \"1\"\r\n   | C  c    -> String.make 1 c    \r\n   | U (f,g) -> \"(\"^(string_of_regexp f)^\" + \"^(string_of_regexp g)^\")\"\r\n   | P (f,g) -> \"(\"^(string_of_regexp f)^\" . \"^(string_of_regexp g)^\")\"\r\n   | S s     -> (string_of_regexp s)^\"*\"\r\n \r\n let () =\r\n  let r = regexp Sys.argv.(1) in\r\n  let () = print_string \"input: \" in\r\n    print_endline (string_of_regexp r)\r\n "}}}
